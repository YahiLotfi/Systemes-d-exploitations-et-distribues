#include <stdio.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/shm.h>
#include <string.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/sem.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#define SHMSZ 100 // taille de la memoire partagée
#define NB_FUTS 2  // nombre de fûts de bière à créer
#define SERVER_IP "127.0.0.1"
#define SERVER_PORT 8888
#define BUFFER_SIZE 1024
// structure de fût de bière
typedef struct {
    char nom[20];
    char couleur[20];
    float quantite;
    int degre;
} FutBiere;

  int main() {
  char mot1[50], mot2[50], mot3[50];
  float quantite;
  int couleur;
  int degre;
  int semid;
  int fd;
  char message[100];
  char message2[100];
  char  messagee[100] ;
  char  messagee2 [100];
 struct sembuf sem_lock = {0, -1, SEM_UNDO};
 struct sembuf sem_unlock = {0, 1, SEM_UNDO};
strcpy(messagee, "boisson servie\0");
strcpy(messagee2, "la boisson n'est pas disponible pour le moment\0");

int sockfd;
  struct sockaddr_in serveraddr;
   char buffer[BUFFER_SIZE]="attention un fut de biere est vide est vide\0";
       char buffer1[1024] = {0};
    char buffer2[1024] = {0};
  char response[BUFFER_SIZE];

  // Create socket
  if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
    perror("socket creation failed");
    exit(EXIT_FAILURE);
  }

  // Configure server address
  memset(&serveraddr, 0, sizeof(serveraddr));
  serveraddr.sin_family = AF_INET;
  serveraddr.sin_port = htons(SERVER_PORT);
  if (inet_pton(AF_INET, SERVER_IP, &serveraddr.sin_addr) <= 0) {
    perror("invalid address");
    exit(EXIT_FAILURE);
  }




 
    int shmid;
    key_t key;
    FutBiere *futs; // pointeur vers la memoire partagée
    int i;

    // génération de la clé pour la mémoire partagée
    if ((key = ftok("memoire_partagee", 'R')) == -1) {
        perror("ftok");
        exit(1);
    }

    // création de la mémoire partagée
    if ((shmid = shmget(key, SHMSZ, IPC_CREAT | 0666)) == -1) {
        perror("shmget");
        exit(1);
    }

    // attachement de la mémoire partagée au pointeur
    if ((futs = shmat(shmid, NULL, 0)) == (FutBiere *) -1) {
        perror("shmat");
        exit(1);
    }
    // création de la sémaphore
    if ((semid = semget(key, 1, IPC_CREAT | 0666)) == -1) {
        perror("semget");
        exit(1);
    }

    // initialisation de la sémaphore
    if (semctl(semid, 0, SETVAL, 1) == -1) {
        perror("semctl");
        exit(1);
    }
    //verouillage de la semaphore
     if (semop(semid, &sem_lock, 1) == -1) {
            perror("semop");
            exit(1);
        }

    // initialisation des fûts de bière
    strcpy(futs[0].nom, "Paix Dieu");
    strcpy(futs[0].couleur, "blonde");
    futs[0].quantite = 5;
    futs[0].degre = 5;
    strcpy(futs[1].nom, "Goudale");
     strcpy(futs[1].couleur, "ambree");
    futs[1].quantite = 1;
    futs[1].degre= 5;
   

    // création d'un processus fils pour le contrôle des fûts de bière
    pid_t pid = fork();

    if (pid == -1) {
        perror("fork");
        exit(1);
    }

    if (pid == 0) {  // processus fils pour le contrôle des fûts de bière
       while (1) {
            for (i = 0; i < NB_FUTS; i++) {
                if (futs[i].quantite <= 0) {
                    
                    // Send message to server
              
                   sendto(sockfd, buffer, strlen(buffer), 0, (const struct sockaddr *)&serveraddr, sizeof(serveraddr));
                   
  printf("Message sent to commande process: %s\n", buffer);
  

  // Receive response from server

 int len = sizeof(serveraddr);
  recvfrom(sockfd, (char *)response, BUFFER_SIZE, 0, (struct sockaddr *)&serveraddr, &len);
  // la reponse recue est une chaine de caractere sous forme "nom couleur degré" , on va donc extraire ces information
  sscanf(response, "%s %s %s", mot1, mot2, mot3);
 
  couleur= atoi(mot2);
  degre= atoi(mot3);
  // mise à jours du fut
  strcpy(futs[i].nom, mot1);
  if(couleur==1){
  strcpy(futs[i].couleur, "ambree");
  } else{
  strcpy(futs[i].couleur, "blonde");
  } 
    futs[i].degre = degre;
    futs[i].quantite=5;
  
   // déverrouillage de la sémaphore
        if (semop(semid, &sem_unlock, 1) == -1) {
            perror("semop");
            exit(1);
        }
    //close(sockfd);
                }
            }
            sleep(2);
        }
    } else {  // processus parent pour la consommation de la bière
        while (1) {
        
        
    // Ouverture du pipe en lecture
    fd = open("mon_pipe", O_RDONLY);

    // Lecture du message dans le pipe
    read(fd, message, 100);
    printf("%s", message);
    if(strstr(message, "afficher liste biere")!= NULL){
    
    for (i = 0; i < NB_FUTS; i++) {
    
    strcat(message, futs[i].nom);
    strcat(message, " ");
    write(fd, messagee, strlen(messagee)+1);
    }
    } else {


    

        // recevoir cmnde
            for (i = 0; i < NB_FUTS; i++) {
             
                if (futs[i].quantite > 0) {
                
                if(strstr(message, futs[i].nom)!= NULL){
                 
                   
                    /*if recue une cmde et que nom biere est meme que fut[i].nom on diminue d 1/2 ou 1L */
                    
                    if(strstr(message, "pinte")!= NULL){
                    
                    futs[i].quantite= futs[i].quantite-1;
                    }
                     if(strstr(message, "demi")!= NULL) {
                    futs[i].quantite= futs[i].quantite-0.5;
                    }
                    printf("Il reste %f litres de bière dans le fût %s\n", futs[i].quantite, futs[i].nom);
                    printf("boisson servie\n");
                    write(fd, messagee, strlen(messagee)+1);
                    }
                    }
                }
                
                if(i==NB_FUTS){
                write(fd, messagee2, strlen(messagee2)+1);
                }
                }
            }
            
            sleep(2);
        }
    

     // détachement de la mémoire partagée
    if (shmdt(futs) == -1) {
        perror("shmdt");
        exit(1);
    }
   
    // Suppression de la mémoire partagée
    shmctl(shmid, IPC_RMID, NULL);

    return 0;
    }
    


